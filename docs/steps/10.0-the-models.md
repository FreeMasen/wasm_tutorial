---
permalink: "/steps/10.0-the-models.html"
title: "Rust Models"
layout: "post"
prev: 
    url: "/steps/10-rescue.html"
    text: "The Wrench"
next: 
    url: "/steps/10.1-define.html"
    text: "Bincode Parser"
---

<div class="explain">
<p>
The server developer was nice enough to share these models with you, to ease development.
There are two basic structures here, a <code>ToDo</code> struct and a <code>Message</code> enum.</p>
<p>
<p>To preface the details of these models there are two concepts you should know about.</p>
Structs are Rust's way of defining objects when defining a struct you can only define fields/properties for an object, not any behavior. All struct methods must be defined in an separate <code>impl</code> block, this just allows for more
flexibility in organizing your code.
</p>
<p>
Enums in rust work a bit differently than standard <code>C</code> style enums, the biggest difference
being the ability to associate dynamic values with cases. The other big difference is that enums can have
<code>impl</code> blocks, meaning that enums can have methods!
</p>
<p>With that out of the way, lets go over how they are being used here.</p>
</div>
### ToDo

```rust
/// This represents a single todo item it will have a unique ID,
/// a flag whether or not it has been completed and
/// the action that should be taken to complete
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub struct ToDo {
    pub id: i32,
    pub complete: bool,
    pub action: String,
}

impl ToDo {
    /// construct a new ToDo item
    pub fn new(id: i32, complete: bool, action: impl Into<String>) -> ToDo {
        ToDo {
            id,
            complete,
            action: action.into()
        }
    }
}
```
<div class="explain">
<p>This struct will represent a ToDo item, it should look familiar to the json definition in our original spec.</p>
<ul>
<li>id - <code>i32</code>: This will be our numeric id.</li>
<li>complete - <code>bool</code>: This will be true or false depending on if the action was completed</li>
<li>action - <code>String</code>: This will be the text describing our action.</li>
</ul>
<p>You will notice that two of the types might look a little strange. <code>i32</code> is rust's keyword for a 32bit signed integer. If you don't know what that means, don't worry too much, just know that signed means it can be negative or positive. The other thing that might look strange is that <code>String</code> has a capital S, that is because this string is actually heap allocated type, if you don't know what that means it really isn't that important at this point.</p>
<p>ToDo also has an <code>impl</code> block defined for it, inside of this block there is 1 function. This function is static (meaning it doesn't need an instance of ToDo) and will act as our constructor. We denote static and instance methods by either providing or omitting the first argument of <code>self</code>, that is how we know this is static (no <code>self</code>). This function takes 3 arguments, a number for the id, a boolean for the completeness and anything that implements a function that will convert it <code>Into</code> a <code>String</code> as the description of the action. I am not going to dig too far into the action variable, just know that rust has a system like <code>interface</code>s to allow for this kind of thing, they are called <code>Trait</code>s. This argument's type is saying it <code>impl</code>ements the <code>Trait</code> named <code>Into</code> specifically a flavor that will convert it into a <code>String</code>. 
</p>
<p>This is a relatively simple data structure, akin to the <a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">Plain Old Object</a> concept. Let move on to our next model.</p>
</div>

### Message

```rust
/// A representation of our messages traveling between
/// the server and the client
#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
pub enum Message {
    /// A message from the client to the server to
    /// get all of the ToDo items
    GetAll,
    /// A message from the server to the client with
    /// all of the todo items include.
    /// This will be returned with every request from the client
    All(Vec<ToDo>),
    /// A message from the client to add a new ToDo to the list
    Add(ToDo),
    /// A message from the client to update an existing ToDo
    Update(ToDo),
    /// A message from the client to remove an existing ToDo
    /// with a matching id
    Remove(i32),
    /// A message from the server with an Error message
    Error(String),
}

impl Message {
    /// Constructor for our Error type
    pub fn for_error(data: impl Into<String>) -> Message {
        Message::Error(data.into())
    }
    /// A convenience function for serializing a message
    /// to Bincode
    pub fn to_bytes(self) -> Vec<u8> {
        serialize(&self).unwrap_or(vec!())
    }
    /// A convenience function for deserializing a message
    /// from Bincode
    pub fn from_bytes(bytes: Vec<u8>) -> Result<Message, String> {
        match deserialize(&bytes) {
            Ok(msg) => Ok(msg),
            Err(e) => Err(format!("{:?}", e))
        }
    }
}
```

<div class="explain">
<p><code>Message</code> is an enumeration, describing the different messages that we will be sending over the wire. In total there are 6 different messages.</p>
<ul>
<li>
<code>GetAll</code> - This is a plain <code>C</code> style case and will be used to denote the client requesting all of the items in a to do list.
</li>
<li>
<code>All(Vec&lt;ToDo&gt;)</code> - This case has an associated value, of a <code>Vec</code> (Rust's growable array type) of the <code>ToDo</code> structs. This case will be the response to <code>GetAll</code>
</li>
<li>
<code>Add(ToDo)</code> - This case has an associated value of a <code>ToDo</code> struct and will be used to add a new item to the data store
</li>
<li>
<code>Update(ToDo)</code> - This case also has an associated value of a <code>ToDo</code> struct that will replace an existing version in the data store
</li>
<li>
<code>Remove(i32)</code> - This case has an associated value of an <code>i32</code> which will match the id of a <code>ToDo</code> item that should be removed from the data store.
</li>
<li>
<code>Error(String)</code> - This case will represent a server error, the associated value will be a <code>String</code> explaining the error
</li>
</ul>
<p>We also have an <code>impl</code> block for the <code>Message</code> type, this has 3 functions defined in it.</p>
<ul>
<li>
<code>for_error</code> - Is a static (no self) function that will build us an <code>Error</code> case using any type that can be converted into a string. 
</li>
<li>
<code>to_bytes</code> - Is an instance method that will attempt to serialize the instance into a <code>Vec</code> of unsigned 8bit integers. This is a convenience for performing the serialization into <code>bincode</code>.
</li>
<li>
<code>from_bytes</code> - Another static function that attempts to convert a <code>Vec</code> of unsigned 8 bit integers into a message. This is a convenience for performing the deserialization from <code>bincode</code>. 
</li>
</ul>
<p>You probably noticed the return type for this function is <code>Result&lt;Message, String&gt;</code> which is something new. Rust provides an enum called <code>Result</code> that has two possible cases either a success value (for us this is <code>Message</code>) and an error value (for us this is <code>String</code>). This is a good way of describing a situation that should return a specific value but might fail. The function provided by <code>bincode</code> to deserialize some bytes could fail, what if the bytes don't match what it is expecting? The way we are using this <code>Result</code> is a example of the power of Rust's enum type.</p>
<p>The <code>match</code> keyword works a lot like a <code>switch</code>, we are putting it before the result of our attempt to deserialize the bytes provided. Since result is an enum we just need to write a case for each of the possible options. This is done by writing the enum case followed by a fat arrow (<code>=></code>) and then a code block, the next case will come after a ','. When an enum case has an associated value we can assign it a variable that will be local to that match arm, so when we write <code>Ok(msg) =></code> we are saying that if this was successful, assign the associated value to the variable <code>msg</code> so I can use it later.</p>

</div>